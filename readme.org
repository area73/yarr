* Yarr : The Reader

In this final part, we'll finally add the ability to read the posts. Guess where to start with it? With the click handler on the 'Title' in the posts-list.

#+begin_src javascript
// components/posts-list.js
import {clicksByClass_} from '../events';
import {markPostAsRead_} from '../models/posts';
.
.
.
let readPost_ = () => {
  let readPostClicks_ = clicksByClass_('post-title');
  return readPostClicks_
      .do(e => e.preventDefault())
      .map(e => e.target.href)
      .flatMap(link => Posts.get(link))
      .do(markPostAsRead_)
      .startWith('');
}

export default render_;
export {readPost_};
#+end_src

Can you guess what we are upto? We have created an Observable which will give us the url of the post to read whenever user clicks on a post's title. Remember we save posts with url as primary_key in IndexedDB, so we can fetch the post by it's url. We'll use this Observable in our reader view which we're going to create next.

But, have you noticed we have functionality to filter posts by read/unread, but no mechanism to mark a post as read? We'll mark the post as read when she open the reader for a post. For that we already have put `markPostAsRead_` in above code. Now ideally we should keep this in Observable chain and handle the error when it happens, but we won't because it' 4 in the morning, I am tired and sleepy, and I heard you wanted to learn. No learning without doing pall. Don't forget to create a pull request.

Let's create it in ~src/models/posts.js~

#+begin_src javascript
let markPostAsRead_ = (post) => Posts.update(post, {read: 'true'});
.
.
export default {posts_, markPostAsRead_};
#+end_src


Create a new file ~src/components/reader.js~

#+begin_src javascript
// components/reader.js
import {Observable} from 'rx';

let view = (post) => {
  if(!post) return '';

  return <section className="post-container post-reader">
  <span className="close-reader-btn">&#10094;</span>
  <header className="post-header">
    <ul className="post-meta-list">
      <li className="post-meta-item">
        <p>{formatDate(post.publishedDate)}</p>
      </li>

      <li className="post-meta-item">
        <p itemprop="articleSection">{post.categories.join(', ')}</p>
      </li>
    </ul>

    <h1 itemprop="name headline" className="post-title">
    <a href={post.link} title="post.title">{post.title}</a>
    </h1>
  </header>

  <div className="post-body">
    {post.content}
  </div>
</section>
}

let render () => Observable.return(view());
#+end_src

That's the basic view for our reader, let's import it in `components/main.js` and put it in main view. We're going to show the reader as a popup reader which'll take over the entire page. Then we'll have a button to close the reader.

#+begin_src javascript
// components/main.js
import h from 'virtual-dom/h';
import {Observable} from 'rx';

import postsList_, {readPost_} from './posts-list';
import sidebar_, {feedFilters_} from './sidebar';
import reader_ from './reader';

let view = (postsList, sidebar, reader) =>
      <div id='container' className='container'>
         <div className="surface">
           <div className="surface-container">
             <div className="content">
               <aside className="cover">{sidebar}</aside>
               <div className="reader">{reader}</div>
               <div className="wrapper">
                 <div className="wrapper-container">{postsList}</div>
               </div>
             </div>
           </div>
         </div>
       </div>
  ;

let render_ = () => Observable.combineLatest(
  postsList_(feedFilters_),
  sidebar_(),
  reader_(readPost_),
  view
);

export default render_;
#+end_src

Notice we also imported `readPost_` from posts-list component and we pass it to reader. Let's move back to ~src/components/reader.js~ and use it to render a reader view.

#+begin_src javascript
import {Observable} from 'rx';
import h from 'virtual-dom/h';
import {formatDate} from '../utils';

let view = (post) => {
  if(!post) return '';

  return <section className="post-container post-reader">
  <span className="close-reader-btn">&#10094;</span>
  <header className="post-header">
    <ul className="post-meta-list">
      <li className="post-meta-item">
        <p>{formatDate(post.publishedDate)}</p>
      </li>

      <li className="post-meta-item">
        <p itemprop="articleSection">{post.categories.join(', ')}</p>
      </li>
    </ul>

    <h1 itemprop="name headline" className="post-title">
    <a href={post.link} title="post.title">{post.title}</a>
    </h1>
  </header>

  <div className="post-body">
    {post.content}
  </div>
</section>
}

let render_ = (readPost_) =>
      readPost_()
      .startWith(false)
      .map(view);

export default render_;
#+end_src

Now if you click on a post's title, you'll see the reader view shows up, but the post is actually an HTML string, i.e there're all HTML tags etc with all those angle brackets. We need to convert this HTML string to something which virtual-dom can render as HTML (hyperscript). Also, the back button isn't really working, so we have to refresh the page to get rid of the reader. Let's make that button work first.


#+begin_src javascript
// components/reader.js
import {clicksByClass_} from '../events';
.
.
let render_ = (readPost_) => {
  let closeBtnClicks_ = clicksByClass_('close-reader-btn');
  return readPost_()
    .startWith(false)
    .merge(closeBtnClicks_)
    .map(postOrClick => {
      if(postOrClick.type === 'click') return false;
      return postOrClick;
    })
    .map(view);
}

export default render_;
#+end_src

This is a bit hackish, again, tell me if you have a better solution for this. Basically what we do is that we create a new view (the whole view, complete view which we give to virtual-dom for re-rendering) every time user clicks on the post title to read it, or click the close button in reader. When user click on the post title, the reader has a post to render and reader view shows up on the screen, but when user clicks on the close button, same stream (Observable) returns false, which makes the reader view an empty string (hint: the view function in components/reader.js).

Finally lets parse that html string we get from RSS feed to hyperscript. For this we've installed html2hscript node module.

#+begin_src javascript
// components/reader.js
import htmlParser from 'html2hscript';
.
.
#+end_src

~htmlParser~ here is a node callback. We need to convert it to an Observable (yea we can do that, I told you in the start I think. FYI you're annoying me now) so we can use it in our chain.

#+begin_src javascript
// components/reader.js
.
.
.
let render_ = (readPost_) => {
  let closeBtnClicks_ = clicksByClass_('close-reader-btn');
  let htmlParser_ = Observable.fromNodeCallback(htmlParser);
  let posts_ = readPost_().share();
.
.
.
#+end_src

~htmlParser_~ will now take an HTML string and will give us an Observable that return the result. And how do we get a value out of an Observable in the chain? Yup, flatMap.

#+begin_src javascript
// components/reader.js

let render_ = (readPost_) => {
  let closeBtnClicks_ = clicksByClass_('close-reader-btn');
  let htmlParser_ = Observable.fromNodeCallback(htmlParser);
  let posts_ = readPost_().share();

  return posts_
    .flatMap(post => {
      if(!post) return Observable.return('');
      post.content = `<div class="reader-post-wrapper">${post.content}</div>`;
      return htmlParser_(post.content)
    })
.
.
.
#+end_src

But we don't want the content only, we want to complete post object. Let's zip the content back in the post. Other than that, ~htmlParser~ don't really give us hyperscript as javascript objects, it give use hyperscript as string. We need to ~eval~ it. Yea I said `zip` 'em. I think there must be a better way of doing this, please let me know if you know the better way.

#+begin_src javascript
// components/reader.js
let render_ = (readPost_) => {
  let closeBtnClicks_ = clicksByClass_('close-reader-btn');
  let htmlParser_ = Observable.fromNodeCallback(htmlParser);
  let posts_ = readPost_().share();

  return posts_
    .flatMap(post => {
      if(!post) return Observable.return('');
      post.content = `<div class="reader-post-wrapper">${post.content}</div>`;
      return htmlParser_(post.content)
    })
    .zip(
      posts_,
      (vContent, post) => {
        if(!post) return post;

        //this is a hack. the htmlParser produces a string, when needs to be `eval`ed with `h` in scope. So.
        window.h = h;
        let newContent = eval(vContent)
        post.content = newContent;
        return post;
      }
    )
.
.
.
#+end_src

The complete ~render_~  looks like this:

#+begin_src javascript
.
.
.
let render_ = (readPost_) => {
  let closeBtnClicks_ = clicksByClass_('close-reader-btn');
  let htmlParser_ = Observable.fromNodeCallback(htmlParser);
  let posts_ = readPost_().share();

  return posts_
    .flatMap(post => {
      if(!post) return Observable.return('');
      post.content = `<div class="reader-post-wrapper">${post.content}</div>`;
      return htmlParser_(post.content)
    })
    .zip(
      posts_,
      (vContent, post) => {
        if(!post) return post;

        //this is a hack. the htmlParser produces a string, when needs to be `eval`ed with `h` in scope. So.
        window.h = h;
        let newContent = eval(vContent)
        post.content = newContent;
        return post;
      }
    )
    .merge(closeBtnClicks_)
    .map(postOrClick => {
      if(postOrClick.type === 'click') return false;
      return postOrClick;
    })
    .startWith(false)
    .map(view);
}

export default render_;
#+end_src

This might not be too straightforward to understand (or perhaps it is), but I am certain there is cleaner way of doing this.

This is the end of our tutorial. We now have a fully functional RSS reader with few features missing.


*Missing Features*

- Ability to remove a Feed
- Showing error/progress notifications

There might be more I've forgotten. Best way of learning is to do something. This is the reason I built this app. I don't know if anyone is going to read this tutorial, but I'm being optimistic and leaving these two features un-done in hope of seeing some pull requests.

Hope you enjoyed the ride.
