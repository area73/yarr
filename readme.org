* Yarr : Sidebar Controls and Models
Our sidebar is way too empty, let's add some controls to it.

- *Post Filtering widget*

  Most RSS readers have ability to filter posts by "Read" and "Unread" (and "All"). Let's add that widget to our sidebar.

  Create a file: ~components/sidebar-filter-widget.js~

  #+begin_src javascript
  //components/sidebar-filter-widget.js

  import h from 'virtual-dom/h';
  import {Observable} from 'rx';

  let view = () =>
    <ul className="sidebar-controls">
      <li className="sidebar-control filter-posts data-filter-all">All</li>
      <li className="sidebar-control filter-posts active data-filter-unread">Unread</li>
      <li className="sidebar-control filter-posts data-filter-read">Read</li>
    </ul>
    ;

  let render_ = () =>
        Observable.return(view())

  export default render_;
  #+end_src

  We need to update our ~components/sidebar.js~ too:

  #+begin_src javascript
  //components/sidebar.js
  import {Observable} from 'rx';
  import h from 'virtual-dom/h';

  import filterWidget_ from './sidebar-feed-filter';

  let view = (filterWidget) =>
    <div className='sidebar-container'>
      <div className="sidebar-brand">
        <h2 className="sidebar-brand">Yarr</h2>
      </div>

      {filterWidget}
    </div>
  ;

  let render_ = () =>
    Observable
    .combineLatest(
      filterWidget_(),
      view
    );

  export default render_;
  #+end_src

  *Interactivity in feed filter widget*

  Let's add some interactivity to our widget. We wanna switch the ~active~ class to the appropriate button on click.

  #+begin_src javascript
  //components/sidebar-filter-widget.js
  import h from 'virtual-dom/h';
  import {Observable} from 'rx';

  import {clicksByClass_} from '../events';

  let view = () =>
    <ul className="sidebar-controls">
      <li className="sidebar-control filter-posts data-filter-all">All</li>
      <li className="sidebar-control filter-posts active data-filter-unread">Unread</li>
      <li className="sidebar-control filter-posts data-filter-read">Read</li>
    </ul>
    ;

  let render_ = () => {
    let widgetClicks_ = clicksByClass_('filter-posts');

    widgetClicks_
      .map(e => e.target)
      .do(el => {
        document.querySelector('.filter-posts.active').classList.remove('active');
        el.classList.add('active');
      })
      .subscribe(e => console.log(e));

    return Observable.return(view());
  }


  export default render_;
  #+end_src

  We get the clicks Observable with ridiculously simple eventing system we setup earlier, and switch classes on the target element. Not we're not using jQuery for switching classes, because of which our code may not work on some older browsers. But you know what? Fuck it. We don't want to support older browsers, not in our play time at least.

- *Fetch Feeds and Add Feed widget*

  Let's add another widget, we might want to fetch our feeds at later time right? And we of course want to add new feeds.

  Create a file: ~components/sidebar-fetch-n-add-widget.js~

  #+begin_src javascript
  //components/sidebar-fetch-n-add-widget.js
  import h from 'virtual-dom/h';
  import {Observable} from 'rx';

  let view = () =>
    <ul className="sidebar-controls">
      <li className="sidebar-control fetch-all-btn">Fetch All Feeds</li>
      <li className="sidebar-control new-feed-btn">Add New Feed
        <input className="new-feed-input" type="url" required />
      </li>
    </ul>
    ;

  let render_ = () =>
        Observable
        .return(view());

  export default render_;
  #+end_src

  We also need to update ~components/sidebar.js~:

  #+begin_src javascript
  //components/sidebar.js
  import {Observable} from 'rx';
  import h from 'virtual-dom/h';

  import filterWidget_ from './sidebar-feed-filter';
  import fetchNAddWidget_ from './sidebar-fetch-n-add-widget';

  let view = (filterWidget, fetchNAddWidget) =>
    <div className='sidebar-container'>
      <div className="sidebar-brand">
        <h2 className="sidebar-brand">Yarr</h2>
      </div>

      {filterWidget}
      {fetchNAddWidget}

    </div>

  let render_ = () =>
    Observable
    .combineLatest(
      filterWidget_(),
      fetchNAddWidget_(),
      view
    );

  export default render_;
  #+end_src

  *Interactivity*

  Notice that we have an ~<input>~ field for adding a feed, but it has ~display: hidden~. We want to toggle it when we click ~Add New Feed~ button.

  #+begin_src javascript
  import h from 'virtual-dom/h';
  import {Observable} from 'rx';

  import {clicksByClass_} from '../events';

  let view = (addFeedInputStyles) =>
    <ul className="sidebar-controls">
      <li className="sidebar-control fetch-all-btn">Fetch All Feeds</li>

      <li className="sidebar-control new-feed-btn">Add New Feed
        <input className="new-feed-input" style={addFeedInputStyles} type="url" required />
      </li>
    </ul>
    ;

  let render_ = () => {
    let addFeedBtnClicks_ = clicksByClass_('new-feed-btn');

    let addFeedInputStyles_ = addFeedBtnClicks_
          .startWith(false)
          .scan(acc => !acc)
          .map(show => show
               ? {display: 'inline-block'}
               : {display: 'none' });

    return Observable
      .combineLatest(
        addFeedInputStyles_,
        view
      );
  }

  export default render_;
  #+end_src

  We could have simply toggled a class on our ~<input>~ field, but this is another way I wanted to demonstrate. Instead of toggeling classes in side-effect code, we can do it in more pure way like this. We create an Observable for inline-styles of the input block, and create an Observable which emits ~{display: 'none'}~ or ~{display: 'inline-block'}~ alternatively when user clicks the `Add New Feed` button. ~scan~ is similar to ~reduce~, Google it.
